# Node Registry Usage Example

This demonstrates how the new NodeRegistry system solves the ParamSet conflict issue.

## Old Way (with ParamSet conflicts)

```rust
fn update_gauges(
    active_sub: Single<(&Health, &Buoyant, &Transform3D, &Ballast), With<PlayerControlled>>,
    mut gauges: ParamSet<(
        Single<&mut GodotNodeHandle, With<PlayerHealthIndicator>>,
        Single<&mut GodotNodeHandle, With<EquilibriumPressureGauge>>,
        Single<&mut GodotNodeHandle, With<TargetDepthGauge>>,
        Single<&mut GodotNodeHandle, With<DepthGauge>>,
        Single<&mut GodotNodeHandle, With<AirReserveGauge>>,
    )>,
) {
    let (health, buoyant, transform, ballast) = active_sub.into_inner();
    let y = transform.as_godot().origin.y;

    // Verbose ParamSet access
    let mut gauge = gauges.p0().get::<GodotGaugeNode>();
    gauge.bind_mut().deref_mut().set_value(health.current);

    let mut gauge = gauges.p1().get::<GodotGaugeNode>();
    gauge.bind_mut().deref_mut().set_value((y - buoyant.equilibrium_point) / 10.0);
    
    // ... etc
}
```

## New Way (with NodeRegistry)

### 1. Custom Godot Node with BevyBundle

```rust
#[derive(GodotClass, BevyBundle)]
#[class(base=Control)]
#[bevy_bundle((PlayerHealthIndicator), (UIElement))]
pub struct HealthGaugeNode {
    base: Base<Control>,
}

// Auto-generated by macro:
// - HealthGaugeNodeBundle (Bevy bundle)
// - HealthGaugeNodeMarker (registry marker)
// - NodeAccess impl for HealthGaugeNodeMarker
```

### 2. Clean System Implementation

```rust
fn update_gauges(
    active_sub: Single<(&Health, &Buoyant, &Transform3D, &Ballast), With<PlayerControlled>>,
    // No more ParamSet! Just marker queries for existence checks
    _health_gauge: Single<Entity, With<PlayerHealthIndicator>>,
    _equilibrium_gauge: Single<Entity, With<EquilibriumPressureGauge>>,
    _depth_gauge: Single<Entity, With<DepthGauge>>,
    // Registry provides typed access without conflicts
    registry: NodeRegistryAccess,
) {
    let (health, buoyant, transform, ballast) = active_sub.into_inner();
    let y = transform.as_godot().origin.y;

    // Clean, type-safe access through registry
    if let Some(gauge) = registry.access::<HealthGaugeNodeMarker>() {
        // gauge is a TypedNodeRef<HealthGaugeNode>
        gauge.get().call("set_value".into(), &[health.current.to_variant()]);
    }
    
    if let Some(gauge) = registry.access::<EquilibriumGaugeNodeMarker>() {
        gauge.get().call("set_value".into(), &[(y - buoyant.equilibrium_point / 10.0).to_variant()]);
    }
    
    // ... etc
}
```

### 3. Works with Built-in Types Too

```rust
fn update_sprite_colors(
    // Built-in markers work the same way
    _sprites: Query<Entity, With<Sprite2DMarker>>,
    _labels: Query<Entity, With<LabelMarker>>, 
    registry: NodeRegistryAccess,
) {
    // Type-safe access to built-in Godot nodes
    if let Some(sprite) = registry.access::<Sprite2DMarker>() {
        sprite.get().set_modulate(Color::RED);
    }
    
    if let Some(label) = registry.access::<LabelMarker>() {
        label.get().set_text("Updated!".into());
    }
}
```

## Key Benefits

1. **No ParamSet Required** - Eliminates query conflicts completely
2. **Type Safety** - Generated accessors are strongly typed  
3. **Clean API** - Direct node access without boilerplate
4. **Fully Automatic** - Just add `#[derive(BevyBundle)]` to custom nodes
5. **Works with Built-ins** - All 43 built-in Godot node types supported
6. **Consistent Pattern** - Same API for custom and built-in node types
7. **Immediate Registration** - Both built-in and custom markers are registered during scene parsing

## Implementation Status

‚úÖ NodeRegistry resource and NodeAccess trait
‚úÖ Auto-generated NodeAccess for all 43 built-in markers  
‚úÖ Extended BevyBundle macro to generate custom node markers
‚úÖ Integrated with scene tree system (registration happens during parsing!)
‚úÖ Added to GodotPlugin initialization  
‚úÖ **Updated autosync system for automatic custom marker registration**
‚úÖ Compilation successful

## Key Improvement: Registration During Scene Tree Parsing

The final implementation registers **both built-in and custom nodes** immediately during scene tree parsing:

### Built-in Nodes
```rust
// In add_node_type_markers() - called during node creation
if node.try_get::<Sprite2D>().is_some() {
    entity_commands.insert(Sprite2DMarker);
    registry.register_marker::<Sprite2DMarker>(entity); // ‚Üê Immediate registration!
}
```

### Custom BevyBundle Nodes  
```rust
// In generated bundle creation function
fn create_health_gauge_bundle(
    commands: &mut Commands,
    entity: Entity, 
    handle: &GodotNodeHandle,
    registry: &mut NodeRegistry, // ‚Üê Now included!
) -> bool {
    if let Some(node) = handle.try_get::<HealthGaugeNode>() {
        commands.entity(entity).insert(HealthGaugeNodeBundle::from_godot_node(&node));
        commands.entity(entity).insert(HealthGaugeNodeMarker);
        registry.register_marker::<HealthGaugeNodeMarker>(entity); // ‚Üê Automatic!
        return true;
    }
    false
}
```

This means:
- **No double querying** - nodes are available immediately
- **Better performance** - single pass through the scene tree  
- **No race conditions** - registry is updated atomically with entity creation
- **Fully automatic** - works for both built-in and custom node types!

## Real-World Example: Updated Boids Demo

The boids performance test example now demonstrates the system in action:

```rust
// Before: Multiple GodotNodeHandle queries caused conflicts
fn sync_container_params(
    container_query: Query<&GodotNodeHandle, With<BoidsContainer>>,
    // ... other systems with GodotNodeHandle caused ParamSet issues
) { /* ... */ }

// After: Clean registry access
fn sync_container_params(
    _container: Query<Entity, With<BoidsContainer>>, // Just existence check
    registry: NodeRegistryAccess, // Unified access
) {
    if let Some(mut bevy_boids) = registry.access::<BevyBoidsMarker>() {
        // Direct, type-safe access to custom BevyBoids node
        let boids_bind = bevy_boids.bind();
        // ... work with the node
    }
}
```

The system is ready to use and eliminates the ParamSet query conflict issue! üéâ