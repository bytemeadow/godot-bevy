#![allow(clippy::type_complexity)]

use std::fmt::Debug;

use avian3d::{
    collision::CollisionDiagnostics, dynamics::solver::SolverDiagnostics, math::AsF32, prelude::*,
};
use bevy::{prelude::*, scene::ScenePlugin, state::app::StatesPlugin};
use bevy_asset_loader::{
    asset_collection::AssetCollection,
    loading_state::{config::ConfigureLoadingState, LoadingState, LoadingStateAppExt},
};
use godot::{
    builtin::Vector3,
    classes::{BoxMesh, MeshInstance3D},
};
use godot_bevy::prelude::{
    godot_prelude::{gdextension, ExtensionLibrary},
    *,
};

#[bevy_app]
fn build_app(app: &mut App) {
    app.add_plugins(AvianPhysicsDemo);
}

struct AvianPhysicsDemo;

#[derive(Debug, Default, Clone, Eq, PartialEq, Hash, States)]
enum GameState {
    #[default]
    LoadAssets,
    InGame,
}

impl Plugin for AvianPhysicsDemo {
    fn build(&self, app: &mut App) {
        app.add_plugins(StatesPlugin)
            .add_plugins((
                // Plugins required by Avian
                ScenePlugin,
                PhysicsPlugins::default(),
            ))
            // The following 4 resource initializations are required by Avian
            .init_resource::<Assets<Mesh>>()
            .init_resource::<CollisionDiagnostics>()
            .init_resource::<SolverDiagnostics>()
            .init_resource::<SpatialQueryDiagnostics>()
            .insert_resource(Gravity::default())
            .init_state::<GameState>()
            .add_loading_state(
                LoadingState::new(GameState::LoadAssets)
                    .load_collection::<GameAssets>()
                    .continue_to_state(GameState::InGame),
            )
            .add_systems(OnExit(GameState::LoadAssets), spawn_entities)
            .add_systems(
                Update,
                (
                    sync_avian_physics_with_transform.run_if(in_state(GameState::InGame)),
                    query_size.run_if(in_state(GameState::InGame)),
                    // print_tree.run_if(in_state(GameState::InGame).and(run_once)),
                ),
            );
    }
}

#[derive(Component)]
pub struct SimpleBoxTag;

#[derive(AssetCollection, Resource, Debug)]
pub struct GameAssets {
    #[asset(path = "scenes/simple_box.tscn")]
    simple_box_scene: Handle<GodotResource>,

    #[asset(path = "scenes/floor.tscn")]
    floor_scene: Handle<GodotResource>,
}

fn spawn_entities(mut commands: Commands, assets: Res<GameAssets>) {
    //
    // Spawn a static floor
    //
    commands.spawn((
        RigidBody::Static,
        Collider::cuboid(10.0, 0.0, 10.0),
        GodotScene::from_handle(assets.floor_scene.clone()),
    ));

    // GodotScene::from_handle(assets.simple_box_scene.clone()),
    let s = GodotScene::from_path("scenes/simple_box.tscn");

    //
    // Spawn a falling cuboid body with an initial angular velocity
    //
    commands.spawn((
        SimpleBoxTag,
        RigidBody::Dynamic,
        // TODO: it's a chore to have to manually keep the collider dimension values in
        // sync with the Mesh, which is currently in godot's scene. I'm sure we can do
        // better
        Collider::cuboid(1.0, 1.0, 1.0),
        s,
        // GodotScene::from_handle(assets.simple_box_scene.clone()),
        AngularVelocity(Vec3::new(2.5, 3.5, 1.5)),
        // Initialize a bevy transform with the correct starting position so avian's
        // physics simulation is aware of our position. godot-bevy has its own
        // transforms inside of Transform3D, which is generated by GodotScene spawning.
        // We keep avian -> godot-bevy in sync in our `update_system` below
        Transform::default().with_translation(Vec3::new(0., 10., 0.)),
    ));
}

fn query_size(
    mut commands: Commands,
    mut query: Query<&mut GodotNodeHandle, With<SimpleBoxTag>>,
) -> Result {
    if let Ok(mut godot_node_handle) = query.single_mut() {
        let g = godot_node_handle.get::<MeshInstance3D>();
        let mesh = g.get_mesh().unwrap().cast::<BoxMesh>();
        info!("mesh size: {:?}", mesh.get_size());
    }
    Ok(())
}

// TODO: we shouldn't have to do this function since avian has built in syncing, but
// there are at least two problems I'm aware of:
// 1. Our Bundles don't store transform components directly, instead we encase our
//    godot/bevy transforms inside of Transform3D (for _good_ reasons), but that
//    means where avian expects the transform to be isn't quite right and would end
//    up going unused (not reflected in the godot node). I wonder if we
//    can/should rework our Transform3D so our behavior is an extension on Transform itself
//    so we're closer to vanilla bevy and thus avian would "just work"?
// 2. In godot-bevy's scene tree plugin ( https://github.com/dcvz/godot-bevy/blob/main/godot-bevy/src/plugins/core/scene_tree.rs#L259 )
//    we add our spawned entities as *children* of the root window's entity. That
//    plays poorly with the syncing code in avian ( https://github.com/Jondolf/avian/blob/main/src/sync/mod.rs#L317 ),
//    notice that it drops us into a non-existing else case, so nothing happens.
//    I'm not sure what we gain by having our spawned entities follow the parent/child
//    relationship rather than just be flat - need to hear what @dcvz thinks! Even if
//    we made up our own relationship type and used it, avian would be happy.
fn sync_avian_physics_with_transform(
    mut query: Query<(&mut Transform3D, &Position, &Rotation), With<SimpleBoxTag>>,
) -> Result {
    if let Ok((mut transform, position, rotation)) = query.single_mut() {
        // replicating what's being done in the simpel case of avian's sync methods:
        // https://github.com/Jondolf/avian/blob/main/src/sync/mod.rs#L338-L339
        let mut bevy_transform = transform.as_bevy_mut();
        bevy_transform.translation = position.f32();
        bevy_transform.rotation = rotation.f32();
    }

    Ok(())
}
