/*
 * Test framework for godot-bevy integration tests
 */

use godot::classes::Node;
use godot::obj::Gd;
use godot::register::{GodotClass, godot_api};
use std::time::Instant;

mod runner;

use godot::classes::Engine;
use godot::builtin::Signal;

// Plugin registries for collecting tests
godot::sys::plugin_registry!(pub(crate) __GODOT_ITEST: RustTestCase);
godot::sys::plugin_registry!(pub(crate) __GODOT_ASYNC_ITEST: AsyncRustTestCase);

// Re-export itest macro from godot
pub use godot::test::itest;

/// Context passed to each test
#[derive(Clone)]
pub struct TestContext {
    pub scene_tree: Gd<Node>,
}

/// Represents a single synchronous Rust test case
#[derive(Copy, Clone)]
pub struct RustTestCase {
    pub name: &'static str,
    pub file: &'static str,
    pub skipped: bool,
    pub focused: bool,
    pub line: u32,
    pub function: fn(&TestContext),
}

/// Represents a single async Rust test case
#[derive(Copy, Clone)]
pub struct AsyncRustTestCase {
    pub name: &'static str,
    pub file: &'static str,
    pub skipped: bool,
    pub focused: bool,
    pub line: u32,
    pub function: fn(&TestContext) -> godot::task::TaskHandle,
}

/// Main test runner class exposed to Godot
#[derive(GodotClass, Debug)]
#[class(init)]
pub struct IntegrationTests {
    stats: TestStats,
    focus_run: bool,
}

#[derive(Debug, Clone, Default)]
struct TestStats {
    total: usize,
    passed: usize,
    skipped: usize,
    failed_list: Vec<String>,
}

#[godot_api]
impl IntegrationTests {
    /// Run all registered tests
    #[func]
    fn run_all_tests(&mut self, scene_tree: Gd<Node>) -> bool {
        println!(
            "\n{}Run{} godot-bevy integration tests...",
            FMT_CYAN_BOLD, FMT_END
        );

        let tests = self.collect_tests();

        if tests.focus_run {
            println!(
                "  {}Focused run{} -- execute only selected tests.",
                FMT_CYAN, FMT_END
            );
        }

        println!(
            "  Found {} tests in {} files.",
            tests.test_count, tests.file_count
        );

        let clock = Instant::now();
        self.run_tests(tests.tests, scene_tree);
        let elapsed = clock.elapsed();

        self.conclude_tests(elapsed)
    }
}

impl IntegrationTests {
    fn collect_tests(&mut self) -> CollectedTests {
        let mut all_files = std::collections::HashSet::new();
        let mut tests = Vec::new();
        let mut is_focus_run = false;

        godot::sys::plugin_foreach!(__GODOT_ITEST; |test: &RustTestCase| {
            // Switch to focused mode if we encounter a focused test
            if !is_focus_run && test.focused {
                tests.clear();
                all_files.clear();
                is_focus_run = true;
            }

            // Only collect if normal mode or (focus mode and test is focused)
            if !is_focus_run || test.focused {
                all_files.insert(test.file);
                tests.push(*test);
            }
        });

        // Sort for deterministic order
        tests.sort_by_key(|test| (test.file, test.line));

        self.focus_run = is_focus_run;

        let test_count = tests.len();
        let file_count = all_files.len();

        CollectedTests {
            tests,
            test_count,
            file_count,
            focus_run: is_focus_run,
        }
    }

    fn run_tests(&mut self, tests: Vec<RustTestCase>, scene_tree: Gd<Node>) {
        let ctx = TestContext { scene_tree };

        for test in tests {
            if test.skipped {
                println!("  {}[SKIP]{} {}", FMT_YELLOW, FMT_END, test.name);
                self.stats.skipped += 1;
                continue;
            }

            self.stats.total += 1;
            print!("  {} ... ", test.name);

            let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
                (test.function)(&ctx);
            }));

            match result {
                Ok(_) => {
                    println!("{}ok{}", FMT_GREEN, FMT_END);
                    self.stats.passed += 1;
                }
                Err(e) => {
                    let msg = if let Some(s) = e.downcast_ref::<String>() {
                        s.clone()
                    } else if let Some(s) = e.downcast_ref::<&str>() {
                        s.to_string()
                    } else {
                        "unknown panic".to_string()
                    };

                    println!("{}FAILED{}", FMT_RED, FMT_END);
                    println!("    {}", msg);
                    self.stats.failed_list.push(test.name.to_string());
                }
            }
        }
    }

    fn conclude_tests(&self, elapsed: std::time::Duration) -> bool {
        let stats = &self.stats;
        let success = stats.failed_list.is_empty();

        println!("\n{}Test result:{} ", FMT_CYAN_BOLD, FMT_END);

        if success {
            println!(
                "  {}{} passed{}, {} skipped in {:.2}s",
                FMT_GREEN,
                stats.passed,
                FMT_END,
                stats.skipped,
                elapsed.as_secs_f64()
            );
        } else {
            println!(
                "  {}{} passed{}, {}{} failed{}, {} skipped in {:.2}s",
                FMT_GREEN,
                stats.passed,
                FMT_END,
                FMT_RED,
                stats.failed_list.len(),
                FMT_END,
                stats.skipped,
                elapsed.as_secs_f64()
            );
            println!("\n{}Failed tests:{}", FMT_RED, FMT_END);
            for test in &stats.failed_list {
                println!("  - {}", test);
            }
        }

        success
    }
}

struct CollectedTests {
    sync_tests: Vec<RustTestCase>,
    async_tests: Vec<AsyncRustTestCase>,
    test_count: usize,
    file_count: usize,
    focus_run: bool,
}

// ANSI color codes for terminal output
const FMT_CYAN_BOLD: &str = "\x1b[36;1m";
const FMT_CYAN: &str = "\x1b[36m";
const FMT_GREEN: &str = "\x1b[32m";
const FMT_YELLOW: &str = "\x1b[33m";
const FMT_RED: &str = "\x1b[31m";
const FMT_END: &str = "\x1b[0m";

/// Helper function to wait for the next Godot process frame
/// This allows async tests to yield control back to Godot's frame loop
pub async fn await_frame() {
    let tree = Engine::singleton()
        .get_main_loop()
        .expect("Main loop should exist")
        .cast::<godot::classes::SceneTree>();

    let signal = Signal::from_object_signal(&tree, "process_frame");
    let _: () = signal.to_future().await;
}

/// Helper function to wait for multiple frames
pub async fn await_frames(count: u32) {
    for _ in 0..count {
        await_frame().await;
    }
}
