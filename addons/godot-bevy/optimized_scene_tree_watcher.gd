extends Node
class_name OptimizedSceneTreeWatcher

# ðŸ¤– This file is automatically generated by scripts/generate_godot_types.py
# To regenerate: python scripts/generate_godot_types.py

# Optimized Scene Tree Watcher
# This GDScript class intercepts scene tree events and performs type analysis
# on the GDScript side to avoid expensive FFI calls from Rust.

# Reference to the Rust SceneTreeWatcher
var rust_watcher: Node = null

func _ready():
	name = "OptimizedSceneTreeWatcher"
	
	# Auto-detect the Rust SceneTreeWatcher
	var bevy_app = get_node("/root/BevyAppSingleton")
	if bevy_app:
		rust_watcher = bevy_app.get_node("SceneTreeWatcher")
	
	# Connect to scene tree signals - these will forward to Rust with type info
	# Use immediate connections for add/remove to get events as early as possible
	get_tree().node_added.connect(_on_node_added)
	get_tree().node_removed.connect(_on_node_removed) 
	get_tree().node_renamed.connect(_on_node_renamed, CONNECT_DEFERRED)

func set_rust_watcher(watcher: Node):
	"""Called from Rust to set the SceneTreeWatcher reference (optional)"""
	rust_watcher = watcher

func _on_node_added(node: Node):
	"""Handle node added events with type optimization"""
	if not rust_watcher:
		return
	
	# Check if node is still valid
	if not is_instance_valid(node):
		return
	
	# Analyze node type on GDScript side - this is much faster than FFI
	var node_type = _analyze_node_type(node)
	
	# Forward to Rust watcher with pre-analyzed type - this uses the MPSC sender
	if rust_watcher.has_method("scene_tree_event_typed"):
		rust_watcher.scene_tree_event_typed(node, "NodeAdded", node_type)
	else:
		# Fallback to regular method if typed method not available
		rust_watcher.scene_tree_event(node, "NodeAdded")

func _on_node_removed(node: Node):
	"""Handle node removed events - no type analysis needed for removal"""
	if not rust_watcher:
		return
	
	# This is called immediately (not deferred) so the node should still be valid
	# We need to send this event so Rust can clean up the corresponding Bevy entity
	rust_watcher.scene_tree_event(node, "NodeRemoved")

func _on_node_renamed(node: Node):
	"""Handle node renamed events - no type analysis needed for renaming"""
	if not rust_watcher:
		return
	
	# Check if node is still valid
	if not is_instance_valid(node):
		return
		
	rust_watcher.scene_tree_event(node, "NodeRenamed")

func _analyze_node_type(node: Node) -> String:
	"""
	Analyze node type hierarchy on GDScript side.
	Returns the most specific built-in Godot type name.
	This avoids multiple FFI calls that would be needed on the Rust side.
	Generated from Godot extension API to ensure completeness.
	"""
	
	# Check Node3D hierarchy first (most common in 3D games)
	if node is Node3D:
		if node is MeshInstance3D: return "MeshInstance3D"
		if node is StaticBody3D: return "StaticBody3D"
		if node is RigidBody3D: return "RigidBody3D"
		if node is CharacterBody3D: return "CharacterBody3D"
		if node is Area3D: return "Area3D"
		if node is Camera3D: return "Camera3D"
		if node is DirectionalLight3D: return "DirectionalLight3D"
		if node is OmniLight3D: return "OmniLight3D"
		if node is SpotLight3D: return "SpotLight3D"
		if node is CollisionShape3D: return "CollisionShape3D"
		if node is AnimatableBody3D: return "AnimatableBody3D"
		if node is AnimatedSprite3D: return "AnimatedSprite3D"
		if node is AudioListener3D: return "AudioListener3D"
		if node is AudioStreamPlayer3D: return "AudioStreamPlayer3D"
		if node is BoneAttachment3D: return "BoneAttachment3D"
		if node is CPUParticles3D: return "CPUParticles3D"
		if node is CollisionObject3D: return "CollisionObject3D"
		if node is CollisionPolygon3D: return "CollisionPolygon3D"
		if node is ConeTwistJoint3D: return "ConeTwistJoint3D"
		if node is Decal: return "Decal"
		if node is GPUParticles3D: return "GPUParticles3D"
		if node is GPUParticlesAttractor3D: return "GPUParticlesAttractor3D"
		if node is GPUParticlesAttractorBox3D: return "GPUParticlesAttractorBox3D"
		if node is GPUParticlesAttractorSphere3D: return "GPUParticlesAttractorSphere3D"
		if node is GPUParticlesAttractorVectorField3D: return "GPUParticlesAttractorVectorField3D"
		if node is GPUParticlesCollision3D: return "GPUParticlesCollision3D"
		if node is GPUParticlesCollisionBox3D: return "GPUParticlesCollisionBox3D"
		if node is GPUParticlesCollisionHeightField3D: return "GPUParticlesCollisionHeightField3D"
		if node is GPUParticlesCollisionSDF3D: return "GPUParticlesCollisionSDF3D"
		if node is GPUParticlesCollisionSphere3D: return "GPUParticlesCollisionSphere3D"
		if node is Generic6DOFJoint3D: return "Generic6DOFJoint3D"
		if node is GeometryInstance3D: return "GeometryInstance3D"
		if node is GridMap: return "GridMap"
		if node is HingeJoint3D: return "HingeJoint3D"
		if node is Joint3D: return "Joint3D"
		if node is Label3D: return "Label3D"
		if node is Light3D: return "Light3D"
		if node is LightmapProbe: return "LightmapProbe"
		if node is LookAtModifier3D: return "LookAtModifier3D"
		if node is Marker3D: return "Marker3D"
		if node is MultiMeshInstance3D: return "MultiMeshInstance3D"
		if node is OccluderInstance3D: return "OccluderInstance3D"
		if node is Path3D: return "Path3D"
		if node is PathFollow3D: return "PathFollow3D"
		if node is PhysicalBone3D: return "PhysicalBone3D"
		if node is PhysicalBoneSimulator3D: return "PhysicalBoneSimulator3D"
		if node is PhysicsBody3D: return "PhysicsBody3D"
		if node is PinJoint3D: return "PinJoint3D"
		if node is RayCast3D: return "RayCast3D"
		if node is ReflectionProbe: return "ReflectionProbe"
		if node is RemoteTransform3D: return "RemoteTransform3D"
		if node is RetargetModifier3D: return "RetargetModifier3D"
		if node is RootMotionView: return "RootMotionView"
		if node is ShapeCast3D: return "ShapeCast3D"
		if node is Skeleton3D: return "Skeleton3D"
		if node is SkeletonIK3D: return "SkeletonIK3D"
		if node is SkeletonModifier3D: return "SkeletonModifier3D"
		if node is SliderJoint3D: return "SliderJoint3D"
		if node is SoftBody3D: return "SoftBody3D"
		if node is SpringArm3D: return "SpringArm3D"
		if node is SpringBoneCollision3D: return "SpringBoneCollision3D"
		if node is SpringBoneCollisionCapsule3D: return "SpringBoneCollisionCapsule3D"
		if node is SpringBoneCollisionPlane3D: return "SpringBoneCollisionPlane3D"
		if node is SpringBoneCollisionSphere3D: return "SpringBoneCollisionSphere3D"
		if node is SpringBoneSimulator3D: return "SpringBoneSimulator3D"
		if node is Sprite3D: return "Sprite3D"
		if node is SpriteBase3D: return "SpriteBase3D"
		if node is VehicleBody3D: return "VehicleBody3D"
		if node is VehicleWheel3D: return "VehicleWheel3D"
		if node is VisibleOnScreenEnabler3D: return "VisibleOnScreenEnabler3D"
		if node is VisibleOnScreenNotifier3D: return "VisibleOnScreenNotifier3D"
		if node is VisualInstance3D: return "VisualInstance3D"
		return "Node3D"

	# Check Node2D hierarchy (common in 2D games)
	elif node is Node2D:
		if node is Sprite2D: return "Sprite2D"
		if node is StaticBody2D: return "StaticBody2D"
		if node is RigidBody2D: return "RigidBody2D"
		if node is CharacterBody2D: return "CharacterBody2D"
		if node is Area2D: return "Area2D"
		if node is Camera2D: return "Camera2D"
		if node is CollisionShape2D: return "CollisionShape2D"
		if node is AnimatedSprite2D: return "AnimatedSprite2D"
		if node is AnimatableBody2D: return "AnimatableBody2D"
		if node is AudioListener2D: return "AudioListener2D"
		if node is AudioStreamPlayer2D: return "AudioStreamPlayer2D"
		if node is BackBufferCopy: return "BackBufferCopy"
		if node is Bone2D: return "Bone2D"
		if node is CPUParticles2D: return "CPUParticles2D"
		if node is CanvasGroup: return "CanvasGroup"
		if node is CanvasModulate: return "CanvasModulate"
		if node is CollisionObject2D: return "CollisionObject2D"
		if node is CollisionPolygon2D: return "CollisionPolygon2D"
		if node is DampedSpringJoint2D: return "DampedSpringJoint2D"
		if node is DirectionalLight2D: return "DirectionalLight2D"
		if node is GPUParticles2D: return "GPUParticles2D"
		if node is GrooveJoint2D: return "GrooveJoint2D"
		if node is Joint2D: return "Joint2D"
		if node is Light2D: return "Light2D"
		if node is LightOccluder2D: return "LightOccluder2D"
		if node is Line2D: return "Line2D"
		if node is Marker2D: return "Marker2D"
		if node is MeshInstance2D: return "MeshInstance2D"
		if node is MultiMeshInstance2D: return "MultiMeshInstance2D"
		if node is ParallaxLayer: return "ParallaxLayer"
		if node is Path2D: return "Path2D"
		if node is PathFollow2D: return "PathFollow2D"
		if node is PhysicalBone2D: return "PhysicalBone2D"
		if node is PhysicsBody2D: return "PhysicsBody2D"
		if node is PinJoint2D: return "PinJoint2D"
		if node is PointLight2D: return "PointLight2D"
		if node is Polygon2D: return "Polygon2D"
		if node is RayCast2D: return "RayCast2D"
		if node is RemoteTransform2D: return "RemoteTransform2D"
		if node is ShapeCast2D: return "ShapeCast2D"
		if node is Skeleton2D: return "Skeleton2D"
		if node is TileMap: return "TileMap"
		if node is TileMapLayer: return "TileMapLayer"
		if node is TouchScreenButton: return "TouchScreenButton"
		if node is VisibleOnScreenEnabler2D: return "VisibleOnScreenEnabler2D"
		if node is VisibleOnScreenNotifier2D: return "VisibleOnScreenNotifier2D"
		return "Node2D"

	# Check Control hierarchy (UI elements)
	elif node is Control:
		if node is Button: return "Button"
		if node is Label: return "Label"
		if node is Panel: return "Panel"
		if node is VBoxContainer: return "VBoxContainer"
		if node is HBoxContainer: return "HBoxContainer"
		if node is MarginContainer: return "MarginContainer"
		if node is ColorRect: return "ColorRect"
		if node is LineEdit: return "LineEdit"
		if node is TextEdit: return "TextEdit"
		if node is CheckBox: return "CheckBox"
		if node is AspectRatioContainer: return "AspectRatioContainer"
		if node is BaseButton: return "BaseButton"
		if node is BoxContainer: return "BoxContainer"
		if node is CenterContainer: return "CenterContainer"
		if node is CheckButton: return "CheckButton"
		if node is CodeEdit: return "CodeEdit"
		if node is ColorPicker: return "ColorPicker"
		if node is ColorPickerButton: return "ColorPickerButton"
		if node is Container: return "Container"
		if node is FlowContainer: return "FlowContainer"
		if node is GridContainer: return "GridContainer"
		if node is HFlowContainer: return "HFlowContainer"
		if node is HScrollBar: return "HScrollBar"
		if node is HSeparator: return "HSeparator"
		if node is HSlider: return "HSlider"
		if node is HSplitContainer: return "HSplitContainer"
		if node is ItemList: return "ItemList"
		if node is LinkButton: return "LinkButton"
		if node is MenuBar: return "MenuBar"
		if node is MenuButton: return "MenuButton"
		if node is NinePatchRect: return "NinePatchRect"
		if node is OptionButton: return "OptionButton"
		if node is PanelContainer: return "PanelContainer"
		if node is ProgressBar: return "ProgressBar"
		if node is Range: return "Range"
		if node is ReferenceRect: return "ReferenceRect"
		if node is RichTextLabel: return "RichTextLabel"
		if node is ScrollBar: return "ScrollBar"
		if node is ScrollContainer: return "ScrollContainer"
		if node is Separator: return "Separator"
		if node is Slider: return "Slider"
		if node is SpinBox: return "SpinBox"
		if node is SplitContainer: return "SplitContainer"
		if node is SubViewportContainer: return "SubViewportContainer"
		if node is TabBar: return "TabBar"
		if node is TabContainer: return "TabContainer"
		if node is TextureButton: return "TextureButton"
		if node is TextureProgressBar: return "TextureProgressBar"
		if node is TextureRect: return "TextureRect"
		if node is Tree: return "Tree"
		if node is VFlowContainer: return "VFlowContainer"
		if node is VScrollBar: return "VScrollBar"
		if node is VSeparator: return "VSeparator"
		if node is VSlider: return "VSlider"
		if node is VSplitContainer: return "VSplitContainer"
		if node is VideoStreamPlayer: return "VideoStreamPlayer"
		return "Control"

	# Check other common node types that inherit directly from Node
	elif node is Timer: return "Timer"
	elif node is AudioStreamPlayer: return "AudioStreamPlayer"
	elif node is HTTPRequest: return "HTTPRequest"
	elif node is CanvasLayer: return "CanvasLayer"
	elif node is AnimationMixer: return "AnimationMixer"
	elif node is CanvasItem: return "CanvasItem"
	elif node is InstancePlaceholder: return "InstancePlaceholder"
	elif node is MultiplayerSpawner: return "MultiplayerSpawner"
	elif node is MultiplayerSynchronizer: return "MultiplayerSynchronizer"
	elif node is Node3D: return "Node3D"
	elif node is ResourcePreloader: return "ResourcePreloader"
	elif node is ShaderGlobalsOverride: return "ShaderGlobalsOverride"
	elif node is Viewport: return "Viewport"
	
	# Default fallback
	return "Node"

func analyze_initial_tree() -> Dictionary:
	"""
	Analyze the entire initial scene tree and return node information with types.
	Returns a Dictionary with PackedArrays for maximum performance:
	{
		"instance_ids": PackedInt64Array,
		"node_types": PackedStringArray
	}
	Used for optimized initial scene tree setup.
	"""
	var instance_ids = PackedInt64Array()
	var node_types = PackedStringArray()
	var root = get_tree().get_root()
	if root:
		_analyze_node_recursive(root, instance_ids, node_types)
	
	return {
		"instance_ids": instance_ids,
		"node_types": node_types
	}

func _analyze_node_recursive(node: Node, instance_ids: PackedInt64Array, node_types: PackedStringArray):
	"""Recursively analyze nodes and collect type information into PackedArrays"""
	# Check if node is still valid before processing
	if not is_instance_valid(node):
		return
	
	# Add this node's information with pre-analyzed type
	var instance_id = node.get_instance_id()
	var node_type = _analyze_node_type(node)
	
	# Only append if we have valid data
	if instance_id != 0 and node_type != "":
		instance_ids.append(instance_id)
		node_types.append(node_type)
	
	# Recursively process children
	for child in node.get_children():
		_analyze_node_recursive(child, instance_ids, node_types)
