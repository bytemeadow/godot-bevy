class_name OptimizedSceneTreeWatcher
extends Node

# ðŸ¤– This file is generated. Changes to it will be lost.
# To regenerate: uv run python -m godot_bevy_codegen

# Generated for Godot version: Godot Engine v4.2.1.stable.official
# If you need support for a different version, swap out `optimized_scene_tree_watcher.gd`
# with `optimized_scene_tree_watcher*_*_*.gd_ignore` of your desired version.

# Optimized Scene Tree Watcher
# This GDScript class intercepts scene tree events and performs type analysis
# on the GDScript side to avoid expensive FFI calls from Rust.
# Handles 237 different Godot node types.

# Reference to the Rust SceneTreeWatcher
var rust_watcher: Node = null

func _ready():
    name = "OptimizedSceneTreeWatcher"

    # Auto-detect the Rust SceneTreeWatcher using multiple strategies:
    # 1. Try production path: /root/BevyAppSingleton (autoload singleton)
    # 2. Try as sibling: get_parent().get_node("SceneTreeWatcher") (test framework)
    # 3. Use set_rust_watcher() if watcher is set externally

    # Strategy 1: Production - BevyApp autoload singleton
    var bevy_app = get_node_or_null("/root/BevyAppSingleton")
    if bevy_app:
        rust_watcher = bevy_app.get_node_or_null("SceneTreeWatcher")

    # Strategy 2: Test environment - sibling node
    if not rust_watcher and get_parent():
        rust_watcher = get_parent().get_node_or_null("SceneTreeWatcher")

    # If still not found, it may be set later via set_rust_watcher()
    if not rust_watcher:
        push_warning("[OptimizedSceneTreeWatcher] SceneTreeWatcher not found. Will wait for set_rust_watcher() call.")

    # Connect to scene tree signals - these will forward to Rust with type info
    # Use immediate connections for add/remove to get events as early as possible
    get_tree().node_added.connect(_on_node_added)
    get_tree().node_removed.connect(_on_node_removed)
    get_tree().node_renamed.connect(_on_node_renamed, CONNECT_DEFERRED)

func set_rust_watcher(watcher: Node):
    """Called from Rust to set the SceneTreeWatcher reference (optional)"""
    rust_watcher = watcher

func _on_node_added(node: Node):
    """Handle node added events with type optimization"""
    if not rust_watcher:
        return

    # Check if node is still valid
    if not is_instance_valid(node):
        return

    # Check if node is marked to be excluded from scene tree watcher
    if node.has_meta("_bevy_exclude"):
        return

    # Analyze node type on GDScript side - this is much faster than FFI
    var node_type = _analyze_node_type(node)
    var node_name = node.name
    var parent = node.get_parent()
    var parent_id = parent and parent.get_instance_id() or 0
    var collision_mask = _compute_collision_mask(node)

    # Collect groups for this node
    var node_groups = PackedStringArray()
    for group in node.get_groups():
        node_groups.append(group)

    # Forward to Rust watcher with pre-analyzed metadata
    # Try newest API first (with groups), then fall back to older APIs
    if rust_watcher.has_method("scene_tree_event_typed_metadata_groups"):
        rust_watcher.scene_tree_event_typed_metadata_groups(
            node,
            "NodeAdded",
            node_type,
            node_name,
            parent_id,
            collision_mask,
            node_groups
        )
    elif rust_watcher.has_method("scene_tree_event_typed_metadata"):
        rust_watcher.scene_tree_event_typed_metadata(
            node,
            "NodeAdded",
            node_type,
            node_name,
            parent_id,
            collision_mask
        )
    elif rust_watcher.has_method("scene_tree_event_typed"):
        rust_watcher.scene_tree_event_typed(node, "NodeAdded", node_type)
    else:
        # Fallback to regular method if typed method not available
        rust_watcher.scene_tree_event(node, "NodeAdded")

func _on_node_removed(node: Node):
    """Handle node removed events - no type analysis needed for removal"""
    if not rust_watcher:
        return

    # This is called immediately (not deferred) so the node should still be valid
    # We need to send this event so Rust can clean up the corresponding Bevy entity
    rust_watcher.scene_tree_event(node, "NodeRemoved")

func _on_node_renamed(node: Node):
    """Handle node renamed events - no type analysis needed for renaming"""
    if not rust_watcher:
        return

    # Check if node is still valid
    if not is_instance_valid(node):
        return

    var node_name = node.name
    if rust_watcher.has_method("scene_tree_event_named"):
        rust_watcher.scene_tree_event_named(node, "NodeRenamed", node_name)
    else:
        rust_watcher.scene_tree_event(node, "NodeRenamed")

func _compute_collision_mask(node: Node) -> int:
    var mask = 0
    if node.has_signal("body_entered"):
        mask |= 1
    if node.has_signal("body_exited"):
        mask |= 2
    if node.has_signal("area_entered"):
        mask |= 4
    if node.has_signal("area_exited"):
        mask |= 8
    return mask

func _analyze_node_type(node: Node) -> String:
    """
    Analyze node type hierarchy on GDScript side.
    Returns the most specific built-in Godot type name.
    This avoids multiple FFI calls that would be needed on the Rust side.
    Generated from Godot extension API to ensure completeness.
    """

    # Check Node3D hierarchy first (most common in 3D games)
    if node is Node3D:
        if node is MeshInstance3D: return "MeshInstance3D"
        if node is StaticBody3D: return "StaticBody3D"
        if node is RigidBody3D: return "RigidBody3D"
        if node is CharacterBody3D: return "CharacterBody3D"
        if node is Area3D: return "Area3D"
        if node is Camera3D: return "Camera3D"
        if node is DirectionalLight3D: return "DirectionalLight3D"
        if node is OmniLight3D: return "OmniLight3D"
        if node is SpotLight3D: return "SpotLight3D"
        if node is CollisionShape3D: return "CollisionShape3D"
        if node is AnimatableBody3D: return "AnimatableBody3D"
        if node is AnimatedSprite3D: return "AnimatedSprite3D"
        if node is AudioListener3D: return "AudioListener3D"
        if node is AudioStreamPlayer3D: return "AudioStreamPlayer3D"
        if node is BoneAttachment3D: return "BoneAttachment3D"
        if node is CPUParticles3D: return "CPUParticles3D"
        if node is CSGBox3D: return "CSGBox3D"
        if node is CSGCombiner3D: return "CSGCombiner3D"
        if node is CSGCylinder3D: return "CSGCylinder3D"
        if node is CSGMesh3D: return "CSGMesh3D"
        if node is CSGPolygon3D: return "CSGPolygon3D"
        if node is CSGPrimitive3D: return "CSGPrimitive3D"
        if node is CSGShape3D: return "CSGShape3D"
        if node is CSGSphere3D: return "CSGSphere3D"
        if node is CSGTorus3D: return "CSGTorus3D"
        if node is CollisionObject3D: return "CollisionObject3D"
        if node is CollisionPolygon3D: return "CollisionPolygon3D"
        if node is ConeTwistJoint3D: return "ConeTwistJoint3D"
        if node is Decal: return "Decal"
        if node is FogVolume: return "FogVolume"
        if node is GPUParticles3D: return "GPUParticles3D"
        if node is GPUParticlesAttractor3D: return "GPUParticlesAttractor3D"
        if node is GPUParticlesAttractorBox3D: return "GPUParticlesAttractorBox3D"
        if node is GPUParticlesAttractorSphere3D: return "GPUParticlesAttractorSphere3D"
        if node is GPUParticlesAttractorVectorField3D: return "GPUParticlesAttractorVectorField3D"
        if node is GPUParticlesCollision3D: return "GPUParticlesCollision3D"
        if node is GPUParticlesCollisionBox3D: return "GPUParticlesCollisionBox3D"
        if node is GPUParticlesCollisionHeightField3D: return "GPUParticlesCollisionHeightField3D"
        if node is GPUParticlesCollisionSDF3D: return "GPUParticlesCollisionSDF3D"
        if node is GPUParticlesCollisionSphere3D: return "GPUParticlesCollisionSphere3D"
        if node is Generic6DOFJoint3D: return "Generic6DOFJoint3D"
        if node is GeometryInstance3D: return "GeometryInstance3D"
        if node is GridMap: return "GridMap"
        if node is HingeJoint3D: return "HingeJoint3D"
        if node is ImporterMeshInstance3D: return "ImporterMeshInstance3D"
        if node is Joint3D: return "Joint3D"
        if node is Label3D: return "Label3D"
        if node is Light3D: return "Light3D"
        if node is LightmapGI: return "LightmapGI"
        if node is LightmapProbe: return "LightmapProbe"
        if node is Marker3D: return "Marker3D"
        if node is MultiMeshInstance3D: return "MultiMeshInstance3D"
        if node is NavigationLink3D: return "NavigationLink3D"
        if node is NavigationObstacle3D: return "NavigationObstacle3D"
        if node is NavigationRegion3D: return "NavigationRegion3D"
        if node is OccluderInstance3D: return "OccluderInstance3D"
        if node is OpenXRHand: return "OpenXRHand"
        if node is Path3D: return "Path3D"
        if node is PathFollow3D: return "PathFollow3D"
        if node is PhysicalBone3D: return "PhysicalBone3D"
        if node is PhysicsBody3D: return "PhysicsBody3D"
        if node is PinJoint3D: return "PinJoint3D"
        if node is RayCast3D: return "RayCast3D"
        if node is ReflectionProbe: return "ReflectionProbe"
        if node is RemoteTransform3D: return "RemoteTransform3D"
        if node is RootMotionView: return "RootMotionView"
        if node is ShapeCast3D: return "ShapeCast3D"
        if node is Skeleton3D: return "Skeleton3D"
        if node is SliderJoint3D: return "SliderJoint3D"
        if node is SoftBody3D: return "SoftBody3D"
        if node is SpringArm3D: return "SpringArm3D"
        if node is Sprite3D: return "Sprite3D"
        if node is SpriteBase3D: return "SpriteBase3D"
        if node is VehicleBody3D: return "VehicleBody3D"
        if node is VehicleWheel3D: return "VehicleWheel3D"
        if node is VisibleOnScreenEnabler3D: return "VisibleOnScreenEnabler3D"
        if node is VisibleOnScreenNotifier3D: return "VisibleOnScreenNotifier3D"
        if node is VisualInstance3D: return "VisualInstance3D"
        if node is VoxelGI: return "VoxelGI"
        if node is XRAnchor3D: return "XRAnchor3D"
        if node is XRCamera3D: return "XRCamera3D"
        if node is XRController3D: return "XRController3D"
        if node is XRNode3D: return "XRNode3D"
        if node is XROrigin3D: return "XROrigin3D"
        return "Node3D"

    # Check Node2D hierarchy (common in 2D games)
    elif node is Node2D:
        if node is Sprite2D: return "Sprite2D"
        if node is StaticBody2D: return "StaticBody2D"
        if node is RigidBody2D: return "RigidBody2D"
        if node is CharacterBody2D: return "CharacterBody2D"
        if node is Area2D: return "Area2D"
        if node is Camera2D: return "Camera2D"
        if node is CollisionShape2D: return "CollisionShape2D"
        if node is AnimatedSprite2D: return "AnimatedSprite2D"
        if node is AnimatableBody2D: return "AnimatableBody2D"
        if node is AudioListener2D: return "AudioListener2D"
        if node is AudioStreamPlayer2D: return "AudioStreamPlayer2D"
        if node is BackBufferCopy: return "BackBufferCopy"
        if node is Bone2D: return "Bone2D"
        if node is CPUParticles2D: return "CPUParticles2D"
        if node is CanvasGroup: return "CanvasGroup"
        if node is CanvasModulate: return "CanvasModulate"
        if node is CollisionObject2D: return "CollisionObject2D"
        if node is CollisionPolygon2D: return "CollisionPolygon2D"
        if node is DampedSpringJoint2D: return "DampedSpringJoint2D"
        if node is DirectionalLight2D: return "DirectionalLight2D"
        if node is GPUParticles2D: return "GPUParticles2D"
        if node is GrooveJoint2D: return "GrooveJoint2D"
        if node is Joint2D: return "Joint2D"
        if node is Light2D: return "Light2D"
        if node is LightOccluder2D: return "LightOccluder2D"
        if node is Line2D: return "Line2D"
        if node is Marker2D: return "Marker2D"
        if node is MeshInstance2D: return "MeshInstance2D"
        if node is MultiMeshInstance2D: return "MultiMeshInstance2D"
        if node is NavigationLink2D: return "NavigationLink2D"
        if node is NavigationObstacle2D: return "NavigationObstacle2D"
        if node is NavigationRegion2D: return "NavigationRegion2D"
        if node is ParallaxLayer: return "ParallaxLayer"
        if node is Path2D: return "Path2D"
        if node is PathFollow2D: return "PathFollow2D"
        if node is PhysicalBone2D: return "PhysicalBone2D"
        if node is PhysicsBody2D: return "PhysicsBody2D"
        if node is PinJoint2D: return "PinJoint2D"
        if node is PointLight2D: return "PointLight2D"
        if node is Polygon2D: return "Polygon2D"
        if node is RayCast2D: return "RayCast2D"
        if node is RemoteTransform2D: return "RemoteTransform2D"
        if node is ShapeCast2D: return "ShapeCast2D"
        if node is Skeleton2D: return "Skeleton2D"
        if node is TileMap: return "TileMap"
        if node is TouchScreenButton: return "TouchScreenButton"
        if node is VisibleOnScreenEnabler2D: return "VisibleOnScreenEnabler2D"
        if node is VisibleOnScreenNotifier2D: return "VisibleOnScreenNotifier2D"
        return "Node2D"

    # Check Control hierarchy (UI elements)
    elif node is Control:
        if node is Button: return "Button"
        if node is Label: return "Label"
        if node is Panel: return "Panel"
        if node is VBoxContainer: return "VBoxContainer"
        if node is HBoxContainer: return "HBoxContainer"
        if node is MarginContainer: return "MarginContainer"
        if node is ColorRect: return "ColorRect"
        if node is LineEdit: return "LineEdit"
        if node is TextEdit: return "TextEdit"
        if node is CheckBox: return "CheckBox"
        if node is AspectRatioContainer: return "AspectRatioContainer"
        if node is BaseButton: return "BaseButton"
        if node is BoxContainer: return "BoxContainer"
        if node is CenterContainer: return "CenterContainer"
        if node is CheckButton: return "CheckButton"
        if node is CodeEdit: return "CodeEdit"
        if node is ColorPicker: return "ColorPicker"
        if node is ColorPickerButton: return "ColorPickerButton"
        if node is Container: return "Container"
        if node is EditorInspector: return "EditorInspector"
        if node is EditorProperty: return "EditorProperty"
        if node is EditorResourcePicker: return "EditorResourcePicker"
        if node is EditorScriptPicker: return "EditorScriptPicker"
        if node is EditorSpinSlider: return "EditorSpinSlider"
        if node is FileSystemDock: return "FileSystemDock"
        if node is FlowContainer: return "FlowContainer"
        if node is GraphEdit: return "GraphEdit"
        if node is GraphElement: return "GraphElement"
        if node is GraphNode: return "GraphNode"
        if node is GridContainer: return "GridContainer"
        if node is HFlowContainer: return "HFlowContainer"
        if node is HScrollBar: return "HScrollBar"
        if node is HSeparator: return "HSeparator"
        if node is HSlider: return "HSlider"
        if node is HSplitContainer: return "HSplitContainer"
        if node is ItemList: return "ItemList"
        if node is LinkButton: return "LinkButton"
        if node is MenuBar: return "MenuBar"
        if node is MenuButton: return "MenuButton"
        if node is NinePatchRect: return "NinePatchRect"
        if node is OptionButton: return "OptionButton"
        if node is PanelContainer: return "PanelContainer"
        if node is ProgressBar: return "ProgressBar"
        if node is Range: return "Range"
        if node is ReferenceRect: return "ReferenceRect"
        if node is RichTextLabel: return "RichTextLabel"
        if node is ScriptEditor: return "ScriptEditor"
        if node is ScriptEditorBase: return "ScriptEditorBase"
        if node is ScrollBar: return "ScrollBar"
        if node is ScrollContainer: return "ScrollContainer"
        if node is Separator: return "Separator"
        if node is Slider: return "Slider"
        if node is SpinBox: return "SpinBox"
        if node is SplitContainer: return "SplitContainer"
        if node is SubViewportContainer: return "SubViewportContainer"
        if node is TabBar: return "TabBar"
        if node is TabContainer: return "TabContainer"
        if node is TextureButton: return "TextureButton"
        if node is TextureProgressBar: return "TextureProgressBar"
        if node is TextureRect: return "TextureRect"
        if node is Tree: return "Tree"
        if node is VFlowContainer: return "VFlowContainer"
        if node is VScrollBar: return "VScrollBar"
        if node is VSeparator: return "VSeparator"
        if node is VSlider: return "VSlider"
        if node is VSplitContainer: return "VSplitContainer"
        if node is VideoStreamPlayer: return "VideoStreamPlayer"
        return "Control"

    # Check other common node types that inherit directly from Node
    elif node is Timer: return "Timer"
    elif node is AudioStreamPlayer: return "AudioStreamPlayer"
    elif node is HTTPRequest: return "HTTPRequest"
    elif node is CanvasLayer: return "CanvasLayer"
    elif node is AnimationMixer: return "AnimationMixer"
    elif node is CanvasItem: return "CanvasItem"
    elif node is EditorFileSystem: return "EditorFileSystem"
    elif node is EditorPlugin: return "EditorPlugin"
    elif node is EditorResourcePreview: return "EditorResourcePreview"
    elif node is InstancePlaceholder: return "InstancePlaceholder"
    elif node is MissingNode: return "MissingNode"
    elif node is MultiplayerSpawner: return "MultiplayerSpawner"
    elif node is MultiplayerSynchronizer: return "MultiplayerSynchronizer"
    elif node is NavigationAgent2D: return "NavigationAgent2D"
    elif node is NavigationAgent3D: return "NavigationAgent3D"
    elif node is Node3D: return "Node3D"
    elif node is ResourcePreloader: return "ResourcePreloader"
    elif node is ShaderGlobalsOverride: return "ShaderGlobalsOverride"
    elif node is SkeletonIK3D: return "SkeletonIK3D"
    elif node is Viewport: return "Viewport"
    elif node is WorldEnvironment: return "WorldEnvironment"

    # Default fallback
    return "Node"


func analyze_initial_tree() -> Dictionary:
    """
    Analyze the entire initial scene tree and return node information with types.
    Returns a Dictionary with PackedArrays for maximum performance:
    {
        "instance_ids": PackedInt64Array,
        "node_types": PackedStringArray,
        "node_names": PackedStringArray,
        "parent_ids": PackedInt64Array,
        "collision_masks": PackedInt64Array,
        "groups": Array[PackedStringArray]  # Added in v2 - may not be present in older addons
    }
    Used for optimized initial scene tree setup.
    """
    var instance_ids = PackedInt64Array()
    var node_types = PackedStringArray()
    var node_names = PackedStringArray()
    var parent_ids = PackedInt64Array()
    var collision_masks = PackedInt64Array()
    var groups = []  # Array of PackedStringArrays
    var root = get_tree().get_root()
    if root:
        _analyze_node_recursive(root, instance_ids, node_types, node_names, parent_ids, collision_masks, groups)

    return {
        "instance_ids": instance_ids,
        "node_types": node_types,
        "node_names": node_names,
        "parent_ids": parent_ids,
        "collision_masks": collision_masks,
        "groups": groups
    }

func _analyze_node_recursive(node: Node, instance_ids: PackedInt64Array, node_types: PackedStringArray, node_names: PackedStringArray, parent_ids: PackedInt64Array, collision_masks: PackedInt64Array, groups: Array):
    """Recursively analyze nodes and collect type information into PackedArrays"""
    # Check if node is still valid before processing
    if not is_instance_valid(node):
        return

    # Check if node is marked to be excluded from scene tree watcher
    if node.has_meta("_bevy_exclude"):
        return

    # Add this node's information with pre-analyzed type
    var instance_id = node.get_instance_id()
    var node_type = _analyze_node_type(node)
    var node_name = node.name
    var parent = node.get_parent()
    var parent_id = parent and parent.get_instance_id() or 0
    var collision_mask = _compute_collision_mask(node)

    # Collect groups for this node
    var node_groups = PackedStringArray()
    for group in node.get_groups():
        node_groups.append(group)

    # Only append if we have valid data
    if instance_id != 0 and node_type != "":
        instance_ids.append(instance_id)
        node_types.append(node_type)
        node_names.append(node_name)
        parent_ids.append(parent_id)
        collision_masks.append(collision_mask)
        groups.append(node_groups)

    # Recursively process children
    for child in node.get_children():
        _analyze_node_recursive(child, instance_ids, node_types, node_names, parent_ids, collision_masks, groups)

